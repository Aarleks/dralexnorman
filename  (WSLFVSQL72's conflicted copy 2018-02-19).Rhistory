filtered_runs$Resting.Heart.Rate,
as.numeric(filtered_runs$average_heartrate))
# Make a plot of the economy data
ggplot(filtered_runs, aes(x = start_date_local, y = economy))+
geom_point(size = 1)+
geom_smooth()
ggplot(filtered_runs, aes(x = start_date_local, y = economy))+
geom_point(size = 1)+
geom_smooth()
# Make a plot of the economy data
ggplot(filtered_runs, aes(x = start_date_local, y = economy)) +
geom_point(size = 1) +
geom_smooth() +
xlab("Date") + ylab("Economy") +
ggtitle("Relative Running Economy")
blogdown:::serve_site()
blogdown::dep_path()
blogdown:::serve_site()
blogdown:::serve_site()
git status
blogdown:::serve_site()
library(rStrava)
library(ggplot2)
library(lubridate)
library(dplyr)
library(googledrive)
# Running Economy function
relative_economy <- function(distance, total_time, restingHR, averageHR){
total_beats <- (averageHR - restingHR) * (total_time/60)
work_per_km <- total_beats/distance
efficiency <- 1 / work_per_km * 100000
return(efficiency)
}
# Strava Account details
app_name <- 'Efficiency Calculator'
app_client_id <- '21764'
app_secret <- '58b36d1840b2d2ce28dff6497945b2a58cca150a'
# create the Strava authentication token
stoken <- httr::config(token = strava_oauth(app_name, app_client_id, app_secret))
# get activities from Strava
my_acts <- get_activity_list(stoken)
# Create a dataframe of activities
runs <- compile_activities(my_acts)
# Change the local time to POSIXct format for later processing
runs$start_date_local <- date(runs$start_date_local)
# Filter the dataframe to the required date range
filtered_runs <- filter(runs, ymd(runs$start_date_local) >= '2017-07-07')
# Get restingHR + bodyweight data from Google Drive
x <- drive_find(pattern = "Weight-RHR Form")
drive_download(x[1,], type = "csv")
weight_heart_data <- select(read.csv("Weight-RHR Form (Responses).csv"),
-Timestamp)
weight_heart_data$Date <- date(dmy(weight_heart_data$Date, tz = "Australia/Sydney"))
# Join the two data frame by date
filtered_runs <- left_join(filtered_runs, weight_heart_data, by = c("start_date_local" = "Date"))
# Insert missing Resting Heart Rate data with a default value
filtered_runs$Resting.Heart.Rate[is.na(filtered_runs$Resting.Hear.Rate)] <- 53
# Add relative running economy data
filtered_runs$economy <- relative_economy(filtered_runs$distance,
filtered_runs$moving_time,
filtered_runs$Resting.Heart.Rate,
as.numeric(filtered_runs$average_heartrate))
# Make a plot of the economy data
ggplot(filtered_runs, aes(x = start_date_local, y = economy)) +
geom_point(size = 1) +
geom_smooth() +
xlab("Date") + ylab("Economy") +
ggtitle("Relative Running Economy")
head(runs)
head(filtered_runs)
library(rStrava)
library(ggplot2)
library(lubridate)
library(dplyr)
library(googledrive)
# Running Economy function
relative_economy <- function(distance, total_time, restingHR, averageHR){
total_beats <- (averageHR - restingHR) * (total_time/60)
work_per_km <- total_beats/distance
efficiency <- 1 / work_per_km * 100000
return(efficiency)
}
app_name <- 'Efficiency Calculator'
app_client_id <- '21764'
app_secret <- '58b36d1840b2d2ce28dff6497945b2a58cca150a'
# create the Strava authentication token
stoken <- httr::config(token = strava_oauth(app_name, app_client_id, app_secret))
# get activities from Strava
my_acts <- get_activity_list(stoken)
# Create a dataframe of activities
runs <- compile_activities(my_acts)
# Change the local time to POSIXct format for later processing
runs$start_date_local <- date(runs$start_date_local)
# Filter the dataframe to the required date range
filtered_runs <- filter(runs, ymd(runs$start_date_local) >= '2017-07-07')
# Get restingHR + bodyweight data from Google Drive
x <- drive_find(pattern = "Weight-RHR Form")
drive_download(x[1,], type = "csv")
weight_heart_data <- select(read.csv("Weight-RHR Form (Responses).csv"),
- Timestamp)
weight_heart_data$Date <- date(dmy(weight_heart_data$Date, tz = "Australia/Sydney"))
# Join the two data frame by date
filtered_runs <- left_join(filtered_runs, weight_heart_data, by = c("start_date_local" = "Date"))
# Insert missing Resting Heart Rate data with a default value
filtered_runs$Resting.Heart.Rate[is.na(filtered_runs$Resting.Heart.Rate)] <- 53
View(filtered_runs)
# Get restingHR + bodyweight data from Google Drive
x <- drive_find(pattern = "Weight-RHR Form")
drive_download(x[1,], type = "csv")
weight_heart_data <- select(read.csv("Weight-RHR Form (Responses).csv"),
- Timestamp)
weight_heart_data$Date <- date(dmy(weight_heart_data$Date, tz = "Australia/Sydney"))
# Join the two data frame by date
filtered_runs <- left_join(filtered_runs, weight_heart_data, by = c("start_date_local" = "Date"))
# Insert missing Resting Heart Rate data with a default value
filtered_runs$Resting.Hear.Rate[is.na(filtered_runs$Resting.Hear.Rate)] <- 53
View(filtered_runs)
library(rStrava)
library(ggplot2)
library(lubridate)
library(dplyr)
library(googledrive)
# Running Economy function
relative_economy <- function(distance, total_time, restingHR, averageHR){
total_beats <- (averageHR - restingHR) * (total_time/60)
work_per_km <- total_beats/distance
efficiency <- 1 / work_per_km * 100000
return(efficiency)
}
# Strava Account details
app_name <- 'Efficiency Calculator'
app_client_id <- '21764'
app_secret <- '58b36d1840b2d2ce28dff6497945b2a58cca150a'
# create the Strava authentication token
stoken <- httr::config(token = strava_oauth(app_name, app_client_id, app_secret))
# get activities from Strava
my_acts <- get_activity_list(stoken)
# Create a dataframe of activities
runs <- compile_activities(my_acts)
# Change the local time to POSIXct format for later processing
runs$start_date_local <- date(runs$start_date_local)
# Filter the dataframe to the required date range
filtered_runs <- filter(runs, ymd(runs$start_date_local) >= '2017-07-07')
# Get restingHR + bodyweight data from Google Drive
x <- drive_find(pattern = "Weight-RHR Form")
drive_download(x[1,], type = "csv")
weight_heart_data <- select(read.csv("Weight-RHR Form (Responses).csv"),
- Timestamp)
weight_heart_data$Date <- date(dmy(weight_heart_data$Date, tz = "Australia/Sydney"))
# Join the two data frame by date
filtered_runs <- left_join(filtered_runs, weight_heart_data, by = c("start_date_local" = "Date"))
View(weight_heart_data)
# Insert missing Resting Heart Rate data with a default value
filtered_runs$Resting.Hear.Rate[is.na(filtered_runs$Resting.Hear.Rate)] <- 53
# Add relative running economy data
filtered_runs$economy <- relative_economy(filtered_runs$distance,
filtered_runs$moving_time,
filtered_runs$Resting.Hear.Rate,
as.numeric(filtered_runs$average_heartrate))
# Make a plot of the economy data
ggplot(filtered_runs, aes(x = start_date_local, y = economy)) +
geom_point(size = 1) +
geom_smooth() +
xlab("Date") + ylab("Economy") +
ggtitle("Relative Running Economy")
head(filtered_runs)
head(filtered_runs$economy, 20)
today()
blogdown:::new_post_addin()
blogdown:::serve_site()
library(rStrava)
library(ggplot2)
library(lubridate)
library(dplyr)
library(googledrive)
# Running Economy function
relative_economy <- function(distance, total_time, restingHR, averageHR){
total_beats <- (averageHR - restingHR) * (total_time/60)
work_per_km <- total_beats/distance
efficiency <- 1 / work_per_km * 100000
return(efficiency)
}
# Strava Account details
app_name <- 'Efficiency Calculator'
app_client_id <- '21764'
app_secret <- '58b36d1840b2d2ce28dff6497945b2a58cca150a'
# create the Strava authentication token
stoken <- httr::config(token = strava_oauth(app_name, app_client_id, app_secret))
# get activities from Strava
my_acts <- get_activity_list(stoken)
# Create a dataframe of activities
runs <- compile_activities(my_acts)
# Change the local time to POSIXct format for later processing
runs$start_date_local <- date(runs$start_date_local)
# Filter the dataframe to the required date range
filtered_runs <- filter(runs, ymd(runs$start_date_local) >= '2017-11-29')
# Get restingHR + bodyweight data from Google Drive
x <- drive_find(pattern = "Weight-RHR Form")
drive_download(x[1,], type = "csv")
weight_heart_data <- select(read.csv("Weight-RHR Form (Responses).csv"),
- Timestamp)
weight_heart_data$Date <- date(dmy(weight_heart_data$Date, tz = "Australia/Sydney"))
# Join the two data frame by date
filtered_runs <- left_join(filtered_runs, weight_heart_data, by = c("start_date_local" = "Date"))
# Insert missing Resting Heart Rate data with a default value
filtered_runs$Resting.Hear.Rate[is.na(filtered_runs$Resting.Hear.Rate)] <- 53
# Add relative running economy data
filtered_runs$economy <- relative_economy(filtered_runs$distance,
filtered_runs$moving_time,
filtered_runs$Resting.Hear.Rate,
as.numeric(filtered_runs$average_heartrate))
# Make a plot of the economy data
ggplot(filtered_runs, aes(x = start_date_local, y = economy)) +
geom_point(size = 1) +
geom_smooth() +
xlab("Date") + ylab("Economy") +
ggtitle("Relative Running Economy")
filtered_runs$economy
head(filtered_runs)
head(filtered_runs, 10)
min(filtered_runs$distance)
filtered_runs$distance
sort(filtered_runs$distance)
tibble(filtered_runs)
run_summary <- select(filtered_runs, c(start_date_local, distance, average_HR, economy))
run_summary <- select(filtered_runs, c(start_date_local, distance, average_heartrate, economy))
run_summary
blogdown:::serve_site()
blogdown:::serve_site()
ggplot(filtered_runs, aes(x = start_date_local, y = economy, colour = distance)) +
geom_point(size = 1) +
geom_smooth() +
xlab("Date") + ylab("Economy") +
ggtitle("Relative Running Economy")
ggplot(filtered_runs, aes(x = start_date_local, y = economy, colour = distance)) +
geom_point(size = 2) +
geom_smooth() +
xlab("Date") + ylab("Economy") +
ggtitle("Relative Running Economy")
sum(filtered_runs$distance)
sum(filtered_runs$elapsed_time)
sum(filtered_runs$elapsed_time)/60
(sum(filtered_runs$elapsed_time)/60)/60
536/79
summarise(filtered_runs)
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_histogram() +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day")
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_bar() +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day")
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_bar(stat = "identity") +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day")
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_bar(stat = "identity") +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day") +
theme_dark()
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_bar(stat = "identity", fill = "#00ffe8") +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day") +
theme_dark()
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_bar(stat = "identity", fill = "#ffe900") +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day") +
theme_dark()
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_bar(stat = "identity", fill = "#f2e135") +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day") +
theme_dark()
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_bar(stat = "identity", fill = "#f2e135") +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day") +
theme_dark()
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_bar(stat = "identity", fill = "#f2e135") +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day") +
theme_dark()
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_bar(stat = "identity", fill = "#f7eb6f") +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day") +
theme_dark()
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_bar(stat = "identity", fill = "blue") +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day") +
theme_dark()
ggplot(filtered_runs, aes(x = start_date_local, y = distance)) +
geom_bar(stat = "identity", fill = "blue") +
xlab("Date") + ylab("Distance") +
ggtitle("Distance per Day")
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
library(rStrava)
library(ggplot2)
library(lubridate)
library(dplyr)
library(googledrive)
# Running Economy function
relative_economy <- function(distance, total_time, restingHR, averageHR){
total_beats <- (averageHR - restingHR) * (total_time/60)
work_per_km <- total_beats/distance
efficiency <- 1 / work_per_km * 100000
return(efficiency)
}
# Strava Account details
app_name <- 'Efficiency Calculator'
app_client_id <- '21764'
app_secret <- '58b36d1840b2d2ce28dff6497945b2a58cca150a'
# create the Strava authentication token
stoken <- httr::config(token = strava_oauth(app_name, app_client_id, app_secret))
# get activities from Strava
my_acts <- get_activity_list(stoken)
# Create a dataframe of activities
runs <- compile_activities(my_acts)
# Change the local time to POSIXct format for later processing
runs$start_date_local <- date(runs$start_date_local)
# Filter the dataframe to the required date range
filtered_runs <- filter(runs, ymd(runs$start_date_local) >= '2017-11-29')
# Get restingHR + bodyweight data from Google Drive
x <- drive_find(pattern = "Weight-RHR Form")
drive_download(x[1,], type = "csv")
weight_heart_data <- select(read.csv("Weight-RHR Form (Responses).csv"),
- Timestamp)
weight_heart_data$Date <- date(dmy(weight_heart_data$Date, tz = "Australia/Sydney"))
# Join the two data frame by date
filtered_runs <- left_join(filtered_runs, weight_heart_data, by = c("start_date_local" = "Date"))
# Insert missing Resting Heart Rate data with a default value
filtered_runs$Resting.Hear.Rate[is.na(filtered_runs$Resting.Hear.Rate)] <- 53
# Add relative running economy data
filtered_runs$economy <- relative_economy(filtered_runs$distance,
filtered_runs$moving_time,
filtered_runs$Resting.Hear.Rate,
as.numeric(filtered_runs$average_heartrate))
# Make a plot of the economy data
ggplot(filtered_runs, aes(x = start_date_local, y = economy, colour = distance)) +
geom_point(size = 2) +
geom_smooth() +
xlab("Date") + ylab("Economy") +
ggtitle("Relative Running Economy")
blogdown:::serve_site()
blogdown:::serve_site()
library(rStrava)
library(ggplot2)
library(lubridate)
library(dplyr)
library(googledrive)
# Running Economy function
relative_economy <- function(distance, total_time, restingHR, averageHR){
total_beats <- (averageHR - restingHR) * (total_time/60)
work_per_km <- total_beats/distance
efficiency <- 1 / work_per_km * 100000
return(efficiency)
}
# Strava Account details
app_name <- 'Efficiency Calculator'
app_client_id <- '21764'
app_secret <- '58b36d1840b2d2ce28dff6497945b2a58cca150a'
# create the Strava authentication token
stoken <- httr::config(token = strava_oauth(app_name, app_client_id, app_secret))
# get activities from Strava
my_acts <- get_activity_list(stoken)
# Create a dataframe of activities
runs <- compile_activities(my_acts)
# Change the local time to POSIXct format for later processing
runs$start_date_local <- date(runs$start_date_local)
# Filter the dataframe to the required date range
filtered_runs <- filter(runs, ymd(runs$start_date_local) >= '2017-11-29')
x <- drive_find(pattern = "Weight-RHR Form")
drive_download(x[1,], type = "csv")
weight_heart_data <- select(read.csv("Weight-RHR Form (Responses).csv"),
- Timestamp)
weight_heart_data$Date <- date(dmy(weight_heart_data$Date, tz = "Australia/Sydney"))
# Join the two data frame by date
filtered_runs <- left_join(filtered_runs, weight_heart_data, by = c("start_date_local" = "Date"))
# Insert missing Resting Heart Rate data with a default value
filtered_runs$Resting.Hear.Rate[is.na(filtered_runs$Resting.Hear.Rate)] <- 53
# Add relative running economy data
filtered_runs$economy <- relative_economy(filtered_runs$distance,
filtered_runs$moving_time,
filtered_runs$Resting.Hear.Rate,
as.numeric(filtered_runs$average_heartrate))
# Make a plot of the economy data
ggplot(filtered_runs, aes(x = start_date_local, y = economy, colour = distance)) +
geom_point(size = 2) +
geom_smooth() +
xlab("Date") + ylab("Economy") +
ggtitle("Relative Running Economy")
# Add relative running economy data
filtered_runs$economy <- relative_economy(filtered_runs$distance,
filtered_runs$moving_time,
filtered_runs$Resting.Hear.Rate,
as.numeric(filtered_runs$average_heartrate))
View(filtered_runs)
# Filter the dataframe to the required date range
filtered_runs <- filter(runs, ymd(runs$start_date_local) >= '2017-11-29' && <= '2018-01-01')
filtered_runs <- filter(runs, ymd(runs$start_date_local) >= '2017-11-29'
& ymd(runs$start_date_local) <= '2018-01-01')
x <- drive_find(pattern = "Weight-RHR Form")
drive_download(x[1,], type = "csv")
weight_heart_data <- select(read.csv("Weight-RHR Form (Responses).csv"),
- Timestamp)
weight_heart_data$Date <- date(dmy(weight_heart_data$Date, tz = "Australia/Sydney"))
# Join the two data frame by date
filtered_runs <- left_join(filtered_runs, weight_heart_data, by = c("start_date_local" = "Date"))
# Insert missing Resting Heart Rate data with a default value
filtered_runs$Resting.Hear.Rate[is.na(filtered_runs$Resting.Hear.Rate)] <- 53
# Add relative running economy data
filtered_runs$economy <- relative_economy(filtered_runs$distance,
filtered_runs$moving_time,
filtered_runs$Resting.Hear.Rate,
as.numeric(filtered_runs$average_heartrate))
# Make a plot of the economy data
ggplot(filtered_runs, aes(x = start_date_local, y = economy, colour = distance)) +
geom_point(size = 2) +
geom_smooth() +
xlab("Date") + ylab("Economy") +
ggtitle("Relative Running Economy")
# Add relative running economy data
filtered_runs$economy <- relative_economy(filtered_runs$distance,
filtered_runs$moving_time,
filtered_runs$Resting.Hear.Rate,
as.numeric(filtered_runs$average_heartrate))
View(filtered_runs)
relative_economy <- function(distance, total_time, restingHR, averageHR){
total_beats <- (averageHR - restingHR) * (total_time/60)
work_per_km <- total_beats/distance
efficiency <- 1 / work_per_km * 100000
return(efficiency)
}
# Insert missing Resting Heart Rate data with a default value
filtered_runs$Resting.Heart.Rate[is.na(filtered_runs$Resting.Heart.Rate)] <- 53
# Add relative running economy data
filtered_runs$economy <- relative_economy(filtered_runs$distance,
filtered_runs$moving_time,
filtered_runs$Resting.Heart.Rate,
as.numeric(filtered_runs$average_heartrate))
# Make a plot of the economy data
ggplot(filtered_runs, aes(x = start_date_local, y = economy, colour = distance)) +
geom_point(size = 2) +
geom_smooth() +
xlab("Date") + ylab("Economy") +
ggtitle("Relative Running Economy")
# Filter the dataframe to the required date range
filtered_runs <- filter(runs, ymd(runs$start_date_local) >= '2017-11-29')
filtered_runs <- left_join(filtered_runs, weight_heart_data,
by = c("start_date_local" = "Date"))
# Insert missing Resting Heart Rate data with a default value
filtered_runs$Resting.Heart.Rate[is.na(filtered_runs$Resting.Heart.Rate)] <- 53
# Add relative running economy data
filtered_runs$economy <- relative_economy(filtered_runs$distance,
filtered_runs$moving_time,
filtered_runs$Resting.Heart.Rate,
as.numeric(filtered_runs$average_heartrate))
# Make a plot of the economy data
ggplot(filtered_runs, aes(x = start_date_local, y = economy, colour = distance)) +
geom_point(size = 2) +
geom_smooth() +
xlab("Date") + ylab("Economy") +
ggtitle("Relative Running Economy")
ggplot(filtered_runs, aes(x = disance, y = economy)) +
geom_point(size = 2) +
ggtitle("Distance and Economy")
# Make a graph of distance by economy
ggplot(filtered_runs, aes(x = distance, y = economy)) +
geom_point(size = 2) +
ggtitle("Distance and Economy")
# Make a graph of distance by economy
ggplot(filtered_runs, aes(x = distance, y = economy, colour = start_date_local)) +
geom_point(size = 2) +
ggtitle("Distance and Economy")
# Training Impulse
TRIMP_exp <- function(duration, resting_HR, max_HR, average_HR){
HRr <- (average_HR - resting_HR)/(max_HR - resting_HR)
y <- exp(1.92 * HRr)
return(duration * HRr * (0.64 * y))
}
TRIMP_exp(30, 40, 200, 130)
TRIMP_exp(45, 48, 180, 149)
TRIMP_exp(12, 48, 180, 149)
TRIMP <- TRIMP_exp(filtered_runs$moving_time,)
TRIMP <- TRIMP_exp(filtered_runs$moving_time,
filtered_runs$Resting.Heart.Rate,
180,
filtered_runs$average_heartrate)
TRIMP <- TRIMP_exp(filtered_runs$moving_time,
filtered_runs$Resting.Heart.Rate,
180,
as.numeric(filtered_runs$average_heartrate))
TRIMP
TRIMP <- TRIMP_exp(filtered_runs$moving_time/60,
filtered_runs$Resting.Heart.Rate,
180,
as.numeric(filtered_runs$average_heartrate))
TRIMP
average(TRIMP)/sd(TRIMP)
mean(TRIMP)/sd(TRIMP)
monotony <- mean(TRIMP)/sd(TRIMP)
sum(TRIMP) * monotony
